(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{312:function(e,t,r){"use strict";r.r(t);var a=r(38),s=Object(a.a)({},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"在nuxt中动态加载vuex模块的踩雷日志"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#在nuxt中动态加载vuex模块的踩雷日志","aria-hidden":"true"}},[e._v("#")]),e._v(" 在Nuxt中动态加载vuex模块的踩雷日志")]),e._v(" "),r("blockquote",[r("p",[e._v("转自："),r("a",{attrs:{href:"https://medium.com/dezchuang/vue-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-%E5%9C%A8-nuxt-%E4%B8%AD%E4%BD%BF%E7%94%A8-vuex-registermodule-%E7%9A%84%E8%B8%A9%E9%9B%B7%E6%97%A5%E8%AA%8C-dde3e0972e44",target:"_blank",rel:"noopener noreferrer"}},[e._v("开发笔记｜在Nuxt中动态加载模块的踩雷日志"),r("OutboundLink")],1)])]),e._v(" "),r("p",[e._v("最近使用nuxt遇到的坑，使用vuex的时候在服务端注册后，在客户端无法调用。这里找到一个相对好点的解决方法，分享一下。")]),e._v(" "),r("h2",{attrs:{id:"问题说明"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#问题说明","aria-hidden":"true"}},[e._v("#")]),e._v(" 问题说明")]),e._v(" "),r("p",[e._v("这个bug是使用者用iOS的Safari在某个页面上操作时，会有「重复送出表单」的现象")]),e._v(" "),r("h2",{attrs:{id:"前置知识"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#前置知识","aria-hidden":"true"}},[e._v("#")]),e._v(" 前置知识")]),e._v(" "),r("p",[e._v("由于这个问题会牵扯到Vue生命周期挂钩，Vuex存储模块，Nuxt相关方法及SSR（服务器端渲染）等观念，建议对这些概念有不清楚的读者可以先从官方文件理解：")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue lifecycle hook"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://vuex.vuejs.org/zh/guide/modules.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vuex module"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://vuex.vuejs.org/zh/guide/modules.html#%E6%A8%A1%E5%9D%97%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vuex registerModule"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://nuxtjs.org/api/#the-asyncdata-method",target:"_blank",rel:"noopener noreferrer"}},[e._v("Nuxt asyncData"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://nuxtjs.org/api/pages-fetch#the-fetch-method",target:"_blank",rel:"noopener noreferrer"}},[e._v("Nuxt fetch"),r("OutboundLink")],1)])]),e._v(" "),r("p",[e._v("Vux生态系中的官方文件写得很详细，而且大部分也都有中文版本可以看，但常常有一些细节只有在英文版才有，所以还是建议尝试读英文版的。")]),e._v(" "),r("h2",{attrs:{id:"问题分析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#问题分析","aria-hidden":"true"}},[e._v("#")]),e._v(" 问题分析")]),e._v(" "),r("p",[e._v("这个案例中使用Vue搭配Vuex及Nuxt来实现，在 lifecycle hook 中把 log打印出来验证只有这个页面有状况，而这一页当初实现时尝试使用 Vuex 的 registerModule 来动态载入 store module，于是来深入了解一下 registerModule 到底出了什么事。")]),e._v(" "),r("p",[e._v("观察devtool的networ，发现在有问题的页面中做SSR完后，也就是直接在这一页重新整理，这时任何有打API的请求都发了两次，而client side render呈现则不会，所以怀疑会不会有「重复注册module」的问题。")]),e._v(" "),r("p",[e._v("Google 后找到这一篇："),r("a",{attrs:{href:"https://github.com/vuejs/vue-ssr-docs/issues/166?source=post_page-----dde3e0972e44----------------------",target:"_blank",rel:"noopener noreferrer"}},[e._v("registerModule would be better to called in beforeCreate instead of asyncData"),r("OutboundLink")],1)]),e._v(" "),r("p",[e._v("这个 issue 原本的问题是在讨论「如果在 asyncData 做 registerModule，那麽 client 端会没有这个 module」。\n原因是因为 asyncData 只会在 server 端被触发，所以如果 client 端需要认得这个 module，就需要利用会在 client 端被触发的 lifecycle hook 再做一次动态模组注册：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("store.registerModule(‘a’, module, { preserveState: true }) \n")])])]),r("p",[e._v("而后面几则回复也有人像我一样遇到「重复注册 module」的问题，把每一条回复看完后，看到有人提供了一个解法的范例：")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://github.com/maoberlehner/well-composed-frontend/commit/b1fa6ec58ef782b0230e11f87e80a4c1a2a5f810#diff-4167ed287472c29e9b46664c039d4466",target:"_blank",rel:"noopener noreferrer"}},[e._v("maoberlehner/well-composed-frontend - Dynamically register store modules"),r("OutboundLink")],1)]),e._v(" "),r("p",[e._v("理解后依照他的方法后修正，就解决了自己项目中，页面会重复发两次 request 的问题，以下就来说明如何解决这个问题。")]),e._v(" "),r("h2",{attrs:{id:"解法分析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#解法分析","aria-hidden":"true"}},[e._v("#")]),e._v(" 解法分析")]),e._v(" "),r("h3",{attrs:{id:"_1-写一个「动态注册-module」的-plugin"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-写一个「动态注册-module」的-plugin","aria-hidden":"true"}},[e._v("#")]),e._v(" 1. 写一个「动态注册 module」的 plugin")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("/plugins/register-store.js\n")])])]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("function registerStore({ module, moduleName, store }) {\n  const moduleIsRegistered =\n    store._modules.root._children[moduleName] !== undefined\n  const stateExists = store.state[moduleName]\n  if (!moduleIsRegistered) {\n    store.registerModule(moduleName, module, { preserveState: stateExists })\n  }\n}\n\nexport default ({ app }, inject) => {\n  inject('registerStore', registerStore)\n}\n")])])]),r("p",[e._v("首先将 registerModule 这个方法包成一个全站都可以使用的 plugin，方便未来其他地方也要动态注册模块时，可以避免再发生这个问题。")]),e._v(" "),r("p",[e._v("这边最核心的关键就是要检查这个 module 是不是已经注册了。")]),e._v(" "),r("p",[e._v("当 server 端已经注册而 client 端还没注册时，就会在 client 端进行注册并利用preserveState 这个属性将 module 中的资料同步到 client 端。")]),e._v(" "),r("h3",{attrs:{id:"_2-在-nuxt-中加-plugin-要在-nuxt-config-js-加设定"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-在-nuxt-中加-plugin-要在-nuxt-config-js-加设定","aria-hidden":"true"}},[e._v("#")]),e._v(" 2. 在 Nuxt 中加 plugin 要在 nuxt.config.js 加设定")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("/nuxt.config.js\n")])])]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("plugins: [\n  { src: '~/plugins/register-store' },\n  ...\n],\n")])])]),r("h3",{attrs:{id:"_3-在需要动态注册模块的那个-page-做-registermodule"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-在需要动态注册模块的那个-page-做-registermodule","aria-hidden":"true"}},[e._v("#")]),e._v(" 3.在需要动态注册模块的那个 page 做 registerModule")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("/pages/myPage.vue\n")])])]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("async fetch({ app, store }) {\n  app.$registerStore({\n    module: MyModule,\n    moduleName: `myModule`,\n    store\n  })\n  await store.dispatch('myModule/INIT_DATA')\n},\nbeforeCreate() {\n  this.$registerStore({\n    module: MyModule,\n    moduleName: `myModule`,\n    store: this.$store\n  })\n},\nbeforeDestroy() {\n  this.$store.unregisterModule('myModule')\n}\n")])])]),r("p",[e._v("这边我使用 Nuxt 中的 fetch 方法在 server 端先做注册 module，并且在注册后做 dispatch 先去取得该页面所需要的初始资料，先存放到 store module 中。")]),e._v(" "),r("p",[e._v("等到 beforeCreate 被触发时，再做一次动态注册 module，由于 beforeCreate 会在 server 与 client 端都被触发，此时因为 plugin 中有做「是否注册过」的检查，就可以避免重複注册的问题。")]),e._v(" "),r("p",[e._v("当时会有问题，可能就是在 client 端没有判断 module 是否已经存在，才会导致该页在做任何 action 时都发出两次的现象。")]),e._v(" "),r("p",[e._v("最后离开该页时，在 beforeDestroy 中做卸载即可完成整个动态注册 module 的实现。")]),e._v(" "),r("h2",{attrs:{id:"结语"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#结语","aria-hidden":"true"}},[e._v("#")]),e._v(" 结语")]),e._v(" "),r("p",[e._v("这是在项目中第一次使用 Vuex 的 registerModule 来开发，就不幸地踩到一个雷。")]),e._v(" "),r("p",[e._v("而 Nuxt 中为了实现 SSR 常会需要考虑 server 与 client 两边资料的问题，所以确实理解 Vue 的生命週期进程与 Vuex、Nuxt中的方法，了解自己所使用的框架与工具的观念细节，才能尽可能避免开发上遇到 tricky bug 的风险")]),e._v(" "),r("h2",{attrs:{id:"参考资料"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考资料","aria-hidden":"true"}},[e._v("#")]),e._v(" 参考资料")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://github.com/vuejs/vue-ssr-docs/issues/166",target:"_blank",rel:"noopener noreferrer"}},[e._v("registerModule would be better to called in beforeCreate instead of asyncData"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://github.com/maoberlehner/well-composed-frontend/commit/b1fa6ec58ef782b0230e11f87e80a4c1a2a5f810#diff-4167ed287472c29e9b46664c039d4466",target:"_blank",rel:"noopener noreferrer"}},[e._v("maoberlehner/well-composed-frontend - Dynamically register store modules"),r("OutboundLink")],1)])])])},[],!1,null,null,null);t.default=s.exports}}]);